import 'dart:async';

import 'package:pulse_dating_app/data/models/ai_conversation_models.dart';
import 'package:pulse_dating_app/domain/entities/user_profile.dart';
import 'package:pulse_dating_app/data/models/message.dart';
import 'package:pulse_dating_app/core/network/api_client.dart';
import 'package:pulse_dating_app/core/errors/ai_error_handler.dart';

/// Smart conversation assistant that provides AI-driven help via backend API
/// ALL AI content is generated by backend - no frontend AI generation
class SmartConversationAssistant {
  static SmartConversationAssistant? _instance;
  static SmartConversationAssistant get instance => 
      _instance ??= SmartConversationAssistant._();
  SmartConversationAssistant._();

  final ApiClient _apiClient = ApiClient.instance;

  /// Analyze conversation using backend AI
  Future<AiConversationAnalysisResponse?> analyzeConversation({
    required String conversationId,
    required List<Message> messages,
    required UserProfile currentUser,
    required UserProfile matchProfile,
    String analysisType = 'comprehensive',
  }) async {
    try {
      // Convert messages to strings for API
      final messageStrings = messages.map((m) {
        final senderName = m.sender?.firstName ?? 'User';
        return '$senderName: ${m.content}';
      }).toList();

      final response = await _apiClient.analyzeConversation(
        messages: messageStrings,
        targetUserId: matchProfile.id,
        analysisType: analysisType,
      );

      if (response.statusCode == 200 && response.data != null) {
        return _parseConversationAnalysisResponse(
          conversationId,
          response.data,
        );
      } else {
        // Use enhanced error handling for non-200 responses
        final errorResult = AiErrorHandler.handleError(
          'API returned status ${response.statusCode}',
          'conversation_analysis',
        );
        AiErrorHandler.logError(errorResult);
        return null;
      }
    } catch (e) {
      // Use enhanced error handling
      final errorResult = AiErrorHandler.handleError(
        e,
        'conversation_analysis',
      );
      AiErrorHandler.logError(errorResult);
      return null;
    }
  }

  /// Parse API response into AiConversationAnalysisResponse
  AiConversationAnalysisResponse _parseConversationAnalysisResponse(
    String conversationId,
    Map<String, dynamic> apiData,
  ) {
    final analysis = apiData['analysis'] ?? {};

    return AiConversationAnalysisResponse(
      requestId: conversationId,
      health: AiConversationHealth(
        status: 'healthy',
        score: (analysis['healthScore'] ?? 0.7).toDouble(),
        concerns: List<String>.from(analysis['concerns'] ?? []),
        strengths: List<String>.from(
          analysis['strengths'] ?? ['Good communication'],
        ),
        summary: analysis['summary'] ?? 'Conversation is progressing well',
      ),
      metrics: AiConversationMetrics(
        messageCount: analysis['messageCount'] ?? 0,
        engagementScore: (analysis['engagementScore'] ?? 0.7).toDouble(),
        responseTimeScore: (analysis['responseTimeScore'] ?? 0.7).toDouble(),
        topicDiversityScore: (analysis['topicDiversityScore'] ?? 0.7)
            .toDouble(),
        emotionalConnectionScore: (analysis['emotionalConnectionScore'] ?? 0.7)
            .toDouble(),
        dominantTopics: List<String>.from(analysis['dominantTopics'] ?? []),
        sentimentAnalysis: Map<String, double>.from(
          analysis['sentimentAnalysis'] ?? {},
        ),
      ),
      suggestions: _parseConversationSuggestions(analysis),
      compatibilityInsights: _parseCompatibilityInsights(analysis),
      confidence: (analysis['confidence'] ?? 0.85).toDouble(),
      generatedAt: DateTime.now(),
    );
  }

  /// Parse conversation suggestions from API response
  List<AiConversationSuggestion> _parseConversationSuggestions(
    Map<String, dynamic> analysis,
  ) {
    final suggestions = analysis['suggestions'] ?? [];
    return List.generate(
      suggestions.length.clamp(0, 3),
      (index) => AiConversationSuggestion(
        id: 'suggestion_$index',
        type: 'reply',
        content: suggestions[index].toString(),
        reasoning: 'AI-generated suggestion based on conversation context',
        confidence: 0.8,
        tags: const ['ai-generated'],
        category: 'conversation',
      ),
    );
  }

  /// Parse compatibility insights from API response
  List<AiCompatibilityInsight> _parseCompatibilityInsights(
    Map<String, dynamic> analysis,
  ) {
    final insights = analysis['compatibilityInsights'] ?? [];
    return List.generate(
      insights.length.clamp(0, 2),
      (index) => AiCompatibilityInsight(
        type: 'strength',
        category: 'communication',
        insight: insights[index].toString(),
        impact: 0.5,
        evidence: const ['conversation analysis'],
      ),
    );
  }

  /// Get AI-generated conversation suggestions from backend
  Future<List<AiConversationSuggestion>> getConversationSuggestions({
    required String conversationId,
    required List<Message> recentMessages,
    required UserProfile userProfile,
    required UserProfile matchProfile,
    int maxSuggestions = 3,
  }) async {
    try {
      // Convert recent messages to strings for API
      final messageStrings = recentMessages.map((m) {
        final senderName = m.sender?.firstName ?? 'User';
        return '$senderName: ${m.content}';
      }).toList();

      final response = await _apiClient.post(
        '/ai/response-suggestions',
        data: {
          'conversationId': conversationId,
          'lastMessage': messageStrings.join('\n'),
          'tone': 'friendly',
          'count': maxSuggestions,
        },
      );

      if (response.statusCode == 200 && response.data != null) {
        final suggestions =
            response.data['suggestions'] as List<dynamic>? ?? [];
        return suggestions
            .asMap()
            .entries
            .map(
              (entry) => AiConversationSuggestion(
                id: 'suggestion_${entry.key}',
                type: 'reply',
                content: entry.value.toString(),
                reasoning:
                    'AI-generated response suggestion based on conversation context',
                confidence: 0.8,
                tags: const ['ai-generated', 'response'],
                category: 'response',
              ),
            )
            .toList();
      } else {
        final errorResult = AiErrorHandler.handleError(
          'API returned status ${response.statusCode}',
          'conversation_suggestions',
        );
        AiErrorHandler.logError(errorResult);
        return _getEmergencySuggestions(maxSuggestions);
      }
    } catch (e) {
      final errorResult = AiErrorHandler.handleError(
        e,
        'conversation_suggestions',
      );
      AiErrorHandler.logError(errorResult);
      return _getEmergencySuggestions(maxSuggestions);
    }
  }

  /// Get AI-generated conversation revival plan from backend
  Future<AiConversationRevivalPlan?> createRevivalPlan({
    required String conversationId,
    required List<Message> messages,
    required UserProfile userProfile,
    required UserProfile matchProfile,
  }) async {
    try {
      // Use conversation starters endpoint for revival suggestions
      final response = await _apiClient.post(
        '/ai/conversation-starters',
        data: {
          'targetUserId': matchProfile.id,
          'style': 'revival',
          'includeQuestion': true,
          'referencePoint': 'previous_conversation',
        },
      );

      if (response.statusCode == 200 && response.data != null) {
        final messages = response.data['messages'] as List<dynamic>? ?? [];

        return AiConversationRevivalPlan(
          planId: 'revival_$conversationId',
          strategy: 'Restart conversation with personalized approach',
          suggestedMessages: messages.map((m) => m.toString()).toList(),
          topicsToExplore: const [
            'shared interests',
            'recent activities',
            'future plans',
          ],
          reasoning:
              'AI-generated revival strategy based on conversation history and user compatibility',
          successProbability: 0.75,
          timeToAct: 'within 24-48 hours',
        );
      } else {
        final errorResult = AiErrorHandler.handleError(
          'API returned status ${response.statusCode}',
          'revival_plan',
        );
        AiErrorHandler.logError(errorResult);
        return null;
      }
    } catch (e) {
      final errorResult = AiErrorHandler.handleError(e, 'revival_plan');
      AiErrorHandler.logError(errorResult);
      return null;
    }
  }

  /// Get AI compatibility insights from backend
  Future<List<AiCompatibilityInsight>> getCompatibilityInsights({
    required UserProfile userProfile,
    required UserProfile matchProfile,
    List<Message>? conversationHistory,
  }) async {
    try {
      final response = await _apiClient.post(
        '/ai/compatibility-insights',
        data: {
          'targetUserId': matchProfile.id,
          'conversationHistory':
              conversationHistory
                  ?.map((m) => '${m.sender?.firstName ?? 'User'}: ${m.content}')
                  .toList() ??
              [],
        },
      );

      if (response.statusCode == 200 && response.data != null) {
        final insights = response.data['insights'] as List<dynamic>? ?? [];
        return insights.asMap().entries.map((entry) => AiCompatibilityInsight(
          type: 'strength',
          category: 'communication',
          insight: entry.value.toString(),
          impact: 0.7,
          evidence: const ['conversation analysis', 'profile compatibility'],
        )).toList();
      } else {
        final errorResult = AiErrorHandler.handleError(
          'API returned status ${response.statusCode}',
          'compatibility_insights',
        );
        AiErrorHandler.logError(errorResult);
        return [];
      }
    } catch (e) {
      final errorResult = AiErrorHandler.handleError(
        e,
        'compatibility_insights',
      );
      AiErrorHandler.logError(errorResult);
      return [];
    }
  }

  List<AiConversationSuggestion> _getEmergencySuggestions(int maxSuggestions) {
    final emergencyMessages = [
      "How's your day going?",
      "What are you up to this weekend?",
      "Tell me something interesting about yourself",
      "What's making you smile today?",
      "Any fun plans coming up?",
    ];

    return emergencyMessages
        .take(maxSuggestions)
        .toList()
        .asMap()
        .entries
        .map((entry) => AiConversationSuggestion(
              id: 'emergency_${entry.key}',
              type: 'question',
              content: entry.value,
              reasoning: 'Emergency fallback suggestion',
              confidence: 0.5,
              tags: ['emergency', 'general'],
            ))
            .toList();
  }
}