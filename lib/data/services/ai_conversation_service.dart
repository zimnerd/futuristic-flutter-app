import 'dart:async';

import 'package:pulse_dating_app/data/models/ai_conversation_models.dart';
import 'package:pulse_dating_app/domain/entities/user_profile.dart';
import 'package:pulse_dating_app/data/models/message.dart';
import 'package:pulse_dating_app/core/network/api_client.dart';
import 'package:pulse_dating_app/core/errors/ai_error_handler.dart';

/// Smart conversation assistant that provides AI-driven help via backend API
/// ALL AI content is generated by backend - no frontend AI generation
class SmartConversationAssistant {
  static SmartConversationAssistant? _instance;
  static SmartConversationAssistant get instance => 
      _instance ??= SmartConversationAssistant._();
  SmartConversationAssistant._();

  final ApiClient _apiClient = ApiClient.instance;

  /// Analyze conversation using backend AI
  Future<AiConversationAnalysisResponse?> analyzeConversation({
    required String conversationId,
    required List<Message> messages,
    required UserProfile currentUser,
    required UserProfile matchProfile,
    String analysisType = 'comprehensive',
  }) async {
    try {
      // Convert messages to strings for API
      final messageStrings = messages.map((m) {
        final senderName = m.sender?.firstName ?? 'User';
        return '$senderName: ${m.content}';
      }).toList();

      final response = await _apiClient.analyzeConversation(
        messages: messageStrings,
        targetUserId: matchProfile.id,
        analysisType: analysisType,
      );

      if (response.statusCode == 200 && response.data != null) {
        return _parseConversationAnalysisResponse(
          conversationId,
          response.data,
        );
      } else {
        // Use enhanced error handling for non-200 responses
        final errorResult = AiErrorHandler.handleError(
          'API returned status ${response.statusCode}',
          'conversation_analysis',
        );
        AiErrorHandler.logError(errorResult);

        if (errorResult.shouldFallbackToMock) {
          return _getMockAnalysisResponse(conversationId);
        } else {
          return null;
        }
      }
    } catch (e) {
      // Use enhanced error handling
      final errorResult = AiErrorHandler.handleError(
        e,
        'conversation_analysis',
      );
      AiErrorHandler.logError(errorResult);

      // Fallback to mock data based on error type
      if (errorResult.shouldFallbackToMock) {
        return _getMockAnalysisResponse(conversationId);
      } else {
        return null;
      }
    }
  }

  /// Parse API response into AiConversationAnalysisResponse
  AiConversationAnalysisResponse _parseConversationAnalysisResponse(
    String conversationId,
    Map<String, dynamic> apiData,
  ) {
    final analysis = apiData['analysis'] ?? {};

    return AiConversationAnalysisResponse(
      requestId: conversationId,
      health: AiConversationHealth(
        status: 'healthy',
        score: (analysis['healthScore'] ?? 0.7).toDouble(),
        concerns: List<String>.from(analysis['concerns'] ?? []),
        strengths: List<String>.from(
          analysis['strengths'] ?? ['Good communication'],
        ),
        summary: analysis['summary'] ?? 'Conversation is progressing well',
      ),
      metrics: AiConversationMetrics(
        messageCount: analysis['messageCount'] ?? 0,
        engagementScore: (analysis['engagementScore'] ?? 0.7).toDouble(),
        responseTimeScore: (analysis['responseTimeScore'] ?? 0.7).toDouble(),
        topicDiversityScore: (analysis['topicDiversityScore'] ?? 0.7)
            .toDouble(),
        emotionalConnectionScore: (analysis['emotionalConnectionScore'] ?? 0.7)
            .toDouble(),
        dominantTopics: List<String>.from(analysis['dominantTopics'] ?? []),
        sentimentAnalysis: Map<String, double>.from(
          analysis['sentimentAnalysis'] ?? {},
        ),
      ),
      suggestions: _parseConversationSuggestions(analysis),
      compatibilityInsights: _parseCompatibilityInsights(analysis),
      confidence: (analysis['confidence'] ?? 0.85).toDouble(),
      generatedAt: DateTime.now(),
    );
  }

  /// Parse conversation suggestions from API response
  List<AiConversationSuggestion> _parseConversationSuggestions(
    Map<String, dynamic> analysis,
  ) {
    final suggestions = analysis['suggestions'] ?? [];
    return List.generate(
      suggestions.length.clamp(0, 3),
      (index) => AiConversationSuggestion(
        id: 'suggestion_$index',
        type: 'reply',
        content: suggestions[index].toString(),
        reasoning: 'AI-generated suggestion based on conversation context',
        confidence: 0.8,
        tags: const ['ai-generated'],
        category: 'conversation',
      ),
    );
  }

  /// Parse compatibility insights from API response
  List<AiCompatibilityInsight> _parseCompatibilityInsights(
    Map<String, dynamic> analysis,
  ) {
    final insights = analysis['compatibilityInsights'] ?? [];
    return List.generate(
      insights.length.clamp(0, 2),
      (index) => AiCompatibilityInsight(
        type: 'strength',
        category: 'communication',
        insight: insights[index].toString(),
        impact: 0.5,
        evidence: const ['conversation analysis'],
      ),
    );
  }

  /// Get AI-generated conversation suggestions from backend
  Future<List<AiConversationSuggestion>> getConversationSuggestions({
    required String conversationId,
    required List<Message> recentMessages,
    required UserProfile userProfile,
    required UserProfile matchProfile,
    int maxSuggestions = 3,
  }) async {
    try {
      // Mock suggestions for development - replace with actual API call
      return _getMockSuggestions(maxSuggestions);
    } catch (e) {
      print('Error getting conversation suggestions: $e');
      return _getEmergencySuggestions(maxSuggestions);
    }
  }

  /// Get AI-generated conversation revival plan from backend
  Future<AiConversationRevivalPlan?> createRevivalPlan({
    required String conversationId,
    required List<Message> messages,
    required UserProfile userProfile,
    required UserProfile matchProfile,
  }) async {
    try {
      // Mock revival plan for development - replace with actual API call
      return _getMockRevivalPlan();
    } catch (e) {
      print('Error creating revival plan: $e');
      return null;
    }
  }

  /// Get AI compatibility insights from backend
  Future<List<AiCompatibilityInsight>> getCompatibilityInsights({
    required UserProfile userProfile,
    required UserProfile matchProfile,
    List<Message>? conversationHistory,
  }) async {
    try {
      // Mock compatibility insights for development - replace with actual API call
      return _getMockCompatibilityInsights();
    } catch (e) {
      print('Error getting compatibility insights: $e');
      return [];
    }
  }

  // Mock data for development

  AiConversationAnalysisResponse _getMockAnalysisResponse(String conversationId) {
    return AiConversationAnalysisResponse(
      requestId: 'mock_request_$conversationId',
      health: AiConversationHealth(
        status: 'healthy',
        score: 0.8,
        concerns: [],
        strengths: ['Good engagement', 'Balanced participation'],
        summary: 'Conversation is progressing well with positive engagement',
      ),
      metrics: AiConversationMetrics(
        messageCount: 15,
        engagementScore: 0.8,
        responseTimeScore: 0.7,
        topicDiversityScore: 0.6,
        emotionalConnectionScore: 0.75,
        dominantTopics: ['travel', 'hobbies', 'lifestyle'],
        sentimentAnalysis: {'positive': 0.8, 'neutral': 0.15, 'negative': 0.05},
      ),
      suggestions: _getMockSuggestions(3),
      compatibilityInsights: _getMockCompatibilityInsights(),
      confidence: 0.85,
      generatedAt: DateTime.now(),
    );
  }

  List<AiConversationSuggestion> _getMockSuggestions(int maxSuggestions) {
    final suggestions = [
      AiConversationSuggestion(
        id: 'suggestion_1',
        type: 'question',
        content: "What's your favorite travel destination?",
        reasoning: 'Both users mentioned loving travel',
        confidence: 0.9,
        tags: ['travel', 'interests'],
      ),
      AiConversationSuggestion(
        id: 'suggestion_2',
        type: 'topic_change',
        content: "Tell me about your weekend plans",
        reasoning: 'Natural conversation progression',
        confidence: 0.8,
        tags: ['casual', 'plans'],
      ),
      AiConversationSuggestion(
        id: 'suggestion_3',
        type: 'reply',
        content: "I love your sense of humor!",
        reasoning: 'User has shown appreciation for humor',
        confidence: 0.7,
        tags: ['compliment', 'personality'],
      ),
    ];
    
    return suggestions.take(maxSuggestions).toList();
  }

  AiConversationRevivalPlan _getMockRevivalPlan() {
    return AiConversationRevivalPlan(
      planId: 'revival_plan_1',
      strategy: 'light_topic',
      suggestedMessages: [
        'Hope you\'re having a great week! ðŸ˜Š',
        'I saw something that reminded me of our conversation about travel...',
      ],
      topicsToExplore: ['weekend plans', 'favorite foods', 'music preferences'],
      reasoning: 'Conversation slowed down, suggest a light topic to re-engage',
      successProbability: 0.8,
      timeToAct: '2-4 hours',
    );
  }

    List<AiCompatibilityInsight> _getMockCompatibilityInsights() {
    return [
      AiCompatibilityInsight(
        type: 'strength',
        category: 'communication',
        insight: 'Both users prefer casual, friendly conversation',
        impact: 0.9,
        evidence: ['Similar response styles', 'Shared humor appreciation'],
      ),
      AiCompatibilityInsight(
        type: 'strength',
        category: 'interests',
        insight: 'Common interests in travel and outdoor activities',
        impact: 0.85,
        evidence: ['Both mentioned travel', 'Outdoor activity preferences'],
      ),
      AiCompatibilityInsight(
        type: 'concern',
        category: 'communication',
        insight: 'Noticeable difference in typical response times',
        impact: -0.3,
        evidence: ['Response time patterns', 'Online activity differences'],
      ),
    ];
  }

  List<AiConversationSuggestion> _getEmergencySuggestions(int maxSuggestions) {
    final emergencyMessages = [
      "How's your day going?",
      "What are you up to this weekend?",
      "Tell me something interesting about yourself",
      "What's making you smile today?",
      "Any fun plans coming up?",
    ];

    return emergencyMessages
        .take(maxSuggestions)
        .toList()
        .asMap()
        .entries
        .map((entry) => AiConversationSuggestion(
              id: 'emergency_${entry.key}',
              type: 'question',
              content: entry.value,
              reasoning: 'Emergency fallback suggestion',
              confidence: 0.5,
              tags: ['emergency', 'general'],
            ))
            .toList();
  }
}